// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: opentelemetry/proto/trace/v1/trace.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Opentelemetry.Proto.Trace.V1 {

  /// <summary>Holder for reflection information generated from opentelemetry/proto/trace/v1/trace.proto</summary>
  public static partial class TraceReflection {

    #region Descriptor
    /// <summary>File descriptor for opentelemetry/proto/trace/v1/trace.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static TraceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CihvcGVudGVsZW1ldHJ5L3Byb3RvL3RyYWNlL3YxL3RyYWNlLnByb3RvEhxv",
            "cGVudGVsZW1ldHJ5LnByb3RvLnRyYWNlLnYxGipvcGVudGVsZW1ldHJ5L3By",
            "b3RvL2NvbW1vbi92MS9jb21tb24ucHJvdG8aLm9wZW50ZWxlbWV0cnkvcHJv",
            "dG8vcmVzb3VyY2UvdjEvcmVzb3VyY2UucHJvdG8iwgEKDVJlc291cmNlU3Bh",
            "bnMSOwoIcmVzb3VyY2UYASABKAsyKS5vcGVudGVsZW1ldHJ5LnByb3RvLnJl",
            "c291cmNlLnYxLlJlc291cmNlEmAKHWluc3RydW1lbnRhdGlvbl9saWJyYXJ5",
            "X3NwYW5zGAIgAygLMjkub3BlbnRlbGVtZXRyeS5wcm90by50cmFjZS52MS5J",
            "bnN0cnVtZW50YXRpb25MaWJyYXJ5U3BhbnMSEgoKc2NoZW1hX3VybBgDIAEo",
            "CSK8AQobSW5zdHJ1bWVudGF0aW9uTGlicmFyeVNwYW5zElYKF2luc3RydW1l",
            "bnRhdGlvbl9saWJyYXJ5GAEgASgLMjUub3BlbnRlbGVtZXRyeS5wcm90by5j",
            "b21tb24udjEuSW5zdHJ1bWVudGF0aW9uTGlicmFyeRIxCgVzcGFucxgCIAMo",
            "CzIiLm9wZW50ZWxlbWV0cnkucHJvdG8udHJhY2UudjEuU3BhbhISCgpzY2hl",
            "bWFfdXJsGAMgASgJIuYHCgRTcGFuEhAKCHRyYWNlX2lkGAEgASgMEg8KB3Nw",
            "YW5faWQYAiABKAwSEwoLdHJhY2Vfc3RhdGUYAyABKAkSFgoOcGFyZW50X3Nw",
            "YW5faWQYBCABKAwSDAoEbmFtZRgFIAEoCRI5CgRraW5kGAYgASgOMisub3Bl",
            "bnRlbGVtZXRyeS5wcm90by50cmFjZS52MS5TcGFuLlNwYW5LaW5kEhwKFHN0",
            "YXJ0X3RpbWVfdW5peF9uYW5vGAcgASgGEhoKEmVuZF90aW1lX3VuaXhfbmFu",
            "bxgIIAEoBhI7CgphdHRyaWJ1dGVzGAkgAygLMicub3BlbnRlbGVtZXRyeS5w",
            "cm90by5jb21tb24udjEuS2V5VmFsdWUSIAoYZHJvcHBlZF9hdHRyaWJ1dGVz",
            "X2NvdW50GAogASgNEjgKBmV2ZW50cxgLIAMoCzIoLm9wZW50ZWxlbWV0cnku",
            "cHJvdG8udHJhY2UudjEuU3Bhbi5FdmVudBIcChRkcm9wcGVkX2V2ZW50c19j",
            "b3VudBgMIAEoDRI2CgVsaW5rcxgNIAMoCzInLm9wZW50ZWxlbWV0cnkucHJv",
            "dG8udHJhY2UudjEuU3Bhbi5MaW5rEhsKE2Ryb3BwZWRfbGlua3NfY291bnQY",
            "DiABKA0SNAoGc3RhdHVzGA8gASgLMiQub3BlbnRlbGVtZXRyeS5wcm90by50",
            "cmFjZS52MS5TdGF0dXMajAEKBUV2ZW50EhYKDnRpbWVfdW5peF9uYW5vGAEg",
            "ASgGEgwKBG5hbWUYAiABKAkSOwoKYXR0cmlidXRlcxgDIAMoCzInLm9wZW50",
            "ZWxlbWV0cnkucHJvdG8uY29tbW9uLnYxLktleVZhbHVlEiAKGGRyb3BwZWRf",
            "YXR0cmlidXRlc19jb3VudBgEIAEoDRqdAQoETGluaxIQCgh0cmFjZV9pZBgB",
            "IAEoDBIPCgdzcGFuX2lkGAIgASgMEhMKC3RyYWNlX3N0YXRlGAMgASgJEjsK",
            "CmF0dHJpYnV0ZXMYBCADKAsyJy5vcGVudGVsZW1ldHJ5LnByb3RvLmNvbW1v",
            "bi52MS5LZXlWYWx1ZRIgChhkcm9wcGVkX2F0dHJpYnV0ZXNfY291bnQYBSAB",
            "KA0imQEKCFNwYW5LaW5kEhkKFVNQQU5fS0lORF9VTlNQRUNJRklFRBAAEhYK",
            "ElNQQU5fS0lORF9JTlRFUk5BTBABEhQKEFNQQU5fS0lORF9TRVJWRVIQAhIU",
            "ChBTUEFOX0tJTkRfQ0xJRU5UEAMSFgoSU1BBTl9LSU5EX1BST0RVQ0VSEAQS",
            "FgoSU1BBTl9LSU5EX0NPTlNVTUVSEAUi3QcKBlN0YXR1cxJWCg9kZXByZWNh",
            "dGVkX2NvZGUYASABKA4yOS5vcGVudGVsZW1ldHJ5LnByb3RvLnRyYWNlLnYx",
            "LlN0YXR1cy5EZXByZWNhdGVkU3RhdHVzQ29kZUICGAESDwoHbWVzc2FnZRgC",
            "IAEoCRI9CgRjb2RlGAMgASgOMi8ub3BlbnRlbGVtZXRyeS5wcm90by50cmFj",
            "ZS52MS5TdGF0dXMuU3RhdHVzQ29kZSLaBQoURGVwcmVjYXRlZFN0YXR1c0Nv",
            "ZGUSHQoZREVQUkVDQVRFRF9TVEFUVVNfQ09ERV9PSxAAEiQKIERFUFJFQ0FU",
            "RURfU1RBVFVTX0NPREVfQ0FOQ0VMTEVEEAESKAokREVQUkVDQVRFRF9TVEFU",
            "VVNfQ09ERV9VTktOT1dOX0VSUk9SEAISKwonREVQUkVDQVRFRF9TVEFUVVNf",
            "Q09ERV9JTlZBTElEX0FSR1VNRU5UEAMSLAooREVQUkVDQVRFRF9TVEFUVVNf",
            "Q09ERV9ERUFETElORV9FWENFRURFRBAEEiQKIERFUFJFQ0FURURfU1RBVFVT",
            "X0NPREVfTk9UX0ZPVU5EEAUSKQolREVQUkVDQVRFRF9TVEFUVVNfQ09ERV9B",
            "TFJFQURZX0VYSVNUUxAGEiwKKERFUFJFQ0FURURfU1RBVFVTX0NPREVfUEVS",
            "TUlTU0lPTl9ERU5JRUQQBxItCilERVBSRUNBVEVEX1NUQVRVU19DT0RFX1JF",
            "U09VUkNFX0VYSEFVU1RFRBAIEi4KKkRFUFJFQ0FURURfU1RBVFVTX0NPREVf",
            "RkFJTEVEX1BSRUNPTkRJVElPThAJEiIKHkRFUFJFQ0FURURfU1RBVFVTX0NP",
            "REVfQUJPUlRFRBAKEicKI0RFUFJFQ0FURURfU1RBVFVTX0NPREVfT1VUX09G",
            "X1JBTkdFEAsSKAokREVQUkVDQVRFRF9TVEFUVVNfQ09ERV9VTklNUExFTUVO",
            "VEVEEAwSKQolREVQUkVDQVRFRF9TVEFUVVNfQ09ERV9JTlRFUk5BTF9FUlJP",
            "UhANEiYKIkRFUFJFQ0FURURfU1RBVFVTX0NPREVfVU5BVkFJTEFCTEUQDhIk",
            "CiBERVBSRUNBVEVEX1NUQVRVU19DT0RFX0RBVEFfTE9TUxAPEioKJkRFUFJF",
            "Q0FURURfU1RBVFVTX0NPREVfVU5BVVRIRU5USUNBVEVEEBAiTgoKU3RhdHVz",
            "Q29kZRIVChFTVEFUVVNfQ09ERV9VTlNFVBAAEhIKDlNUQVRVU19DT0RFX09L",
            "EAESFQoRU1RBVFVTX0NPREVfRVJST1IQAkJuCh9pby5vcGVudGVsZW1ldHJ5",
            "LnByb3RvLnRyYWNlLnYxQgpUcmFjZVByb3RvUAFaPWdpdGh1Yi5jb20vb3Bl",
            "bi10ZWxlbWV0cnkvb3BlbnRlbGVtZXRyeS1wcm90by9nZW4vZ28vdHJhY2Uv",
            "djFiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Opentelemetry.Proto.Common.V1.CommonReflection.Descriptor, global::Opentelemetry.Proto.Resource.V1.ResourceReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Opentelemetry.Proto.Trace.V1.ResourceSpans), global::Opentelemetry.Proto.Trace.V1.ResourceSpans.Parser, new[]{ "Resource", "InstrumentationLibrarySpans", "SchemaUrl" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Opentelemetry.Proto.Trace.V1.InstrumentationLibrarySpans), global::Opentelemetry.Proto.Trace.V1.InstrumentationLibrarySpans.Parser, new[]{ "InstrumentationLibrary", "Spans", "SchemaUrl" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Opentelemetry.Proto.Trace.V1.Span), global::Opentelemetry.Proto.Trace.V1.Span.Parser, new[]{ "TraceId", "SpanId", "TraceState", "ParentSpanId", "Name", "Kind", "StartTimeUnixNano", "EndTimeUnixNano", "Attributes", "DroppedAttributesCount", "Events", "DroppedEventsCount", "Links", "DroppedLinksCount", "Status" }, null, new[]{ typeof(global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind) }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Opentelemetry.Proto.Trace.V1.Span.Types.Event), global::Opentelemetry.Proto.Trace.V1.Span.Types.Event.Parser, new[]{ "TimeUnixNano", "Name", "Attributes", "DroppedAttributesCount" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Opentelemetry.Proto.Trace.V1.Span.Types.Link), global::Opentelemetry.Proto.Trace.V1.Span.Types.Link.Parser, new[]{ "TraceId", "SpanId", "TraceState", "Attributes", "DroppedAttributesCount" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Opentelemetry.Proto.Trace.V1.Status), global::Opentelemetry.Proto.Trace.V1.Status.Parser, new[]{ "DeprecatedCode", "Message", "Code" }, null, new[]{ typeof(global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode), typeof(global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// A collection of InstrumentationLibrarySpans from a Resource.
  /// </summary>
  public sealed partial class ResourceSpans : pb::IMessage<ResourceSpans>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ResourceSpans> _parser = new pb::MessageParser<ResourceSpans>(() => new ResourceSpans());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ResourceSpans> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Opentelemetry.Proto.Trace.V1.TraceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResourceSpans() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResourceSpans(ResourceSpans other) : this() {
      resource_ = other.resource_ != null ? other.resource_.Clone() : null;
      instrumentationLibrarySpans_ = other.instrumentationLibrarySpans_.Clone();
      schemaUrl_ = other.schemaUrl_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResourceSpans Clone() {
      return new ResourceSpans(this);
    }

    /// <summary>Field number for the "resource" field.</summary>
    public const int ResourceFieldNumber = 1;
    private global::Opentelemetry.Proto.Resource.V1.Resource resource_;
    /// <summary>
    /// The resource for the spans in this message.
    /// If this field is not set then no resource info is known.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Opentelemetry.Proto.Resource.V1.Resource Resource {
      get { return resource_; }
      set {
        resource_ = value;
      }
    }

    /// <summary>Field number for the "instrumentation_library_spans" field.</summary>
    public const int InstrumentationLibrarySpansFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Opentelemetry.Proto.Trace.V1.InstrumentationLibrarySpans> _repeated_instrumentationLibrarySpans_codec
        = pb::FieldCodec.ForMessage(18, global::Opentelemetry.Proto.Trace.V1.InstrumentationLibrarySpans.Parser);
    private readonly pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.InstrumentationLibrarySpans> instrumentationLibrarySpans_ = new pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.InstrumentationLibrarySpans>();
    /// <summary>
    /// A list of InstrumentationLibrarySpans that originate from a resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.InstrumentationLibrarySpans> InstrumentationLibrarySpans {
      get { return instrumentationLibrarySpans_; }
    }

    /// <summary>Field number for the "schema_url" field.</summary>
    public const int SchemaUrlFieldNumber = 3;
    private string schemaUrl_ = "";
    /// <summary>
    /// This schema_url applies to the data in the "resource" field. It does not apply
    /// to the data in the "instrumentation_library_spans" field which have their own
    /// schema_url field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SchemaUrl {
      get { return schemaUrl_; }
      set {
        schemaUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ResourceSpans);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ResourceSpans other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Resource, other.Resource)) return false;
      if(!instrumentationLibrarySpans_.Equals(other.instrumentationLibrarySpans_)) return false;
      if (SchemaUrl != other.SchemaUrl) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (resource_ != null) hash ^= Resource.GetHashCode();
      hash ^= instrumentationLibrarySpans_.GetHashCode();
      if (SchemaUrl.Length != 0) hash ^= SchemaUrl.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (resource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Resource);
      }
      instrumentationLibrarySpans_.WriteTo(output, _repeated_instrumentationLibrarySpans_codec);
      if (SchemaUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(SchemaUrl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (resource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Resource);
      }
      instrumentationLibrarySpans_.WriteTo(ref output, _repeated_instrumentationLibrarySpans_codec);
      if (SchemaUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(SchemaUrl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (resource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Resource);
      }
      size += instrumentationLibrarySpans_.CalculateSize(_repeated_instrumentationLibrarySpans_codec);
      if (SchemaUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SchemaUrl);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ResourceSpans other) {
      if (other == null) {
        return;
      }
      if (other.resource_ != null) {
        if (resource_ == null) {
          Resource = new global::Opentelemetry.Proto.Resource.V1.Resource();
        }
        Resource.MergeFrom(other.Resource);
      }
      instrumentationLibrarySpans_.Add(other.instrumentationLibrarySpans_);
      if (other.SchemaUrl.Length != 0) {
        SchemaUrl = other.SchemaUrl;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (resource_ == null) {
              Resource = new global::Opentelemetry.Proto.Resource.V1.Resource();
            }
            input.ReadMessage(Resource);
            break;
          }
          case 18: {
            instrumentationLibrarySpans_.AddEntriesFrom(input, _repeated_instrumentationLibrarySpans_codec);
            break;
          }
          case 26: {
            SchemaUrl = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (resource_ == null) {
              Resource = new global::Opentelemetry.Proto.Resource.V1.Resource();
            }
            input.ReadMessage(Resource);
            break;
          }
          case 18: {
            instrumentationLibrarySpans_.AddEntriesFrom(ref input, _repeated_instrumentationLibrarySpans_codec);
            break;
          }
          case 26: {
            SchemaUrl = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A collection of Spans produced by an InstrumentationLibrary.
  /// </summary>
  public sealed partial class InstrumentationLibrarySpans : pb::IMessage<InstrumentationLibrarySpans>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<InstrumentationLibrarySpans> _parser = new pb::MessageParser<InstrumentationLibrarySpans>(() => new InstrumentationLibrarySpans());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<InstrumentationLibrarySpans> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Opentelemetry.Proto.Trace.V1.TraceReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstrumentationLibrarySpans() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstrumentationLibrarySpans(InstrumentationLibrarySpans other) : this() {
      instrumentationLibrary_ = other.instrumentationLibrary_ != null ? other.instrumentationLibrary_.Clone() : null;
      spans_ = other.spans_.Clone();
      schemaUrl_ = other.schemaUrl_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InstrumentationLibrarySpans Clone() {
      return new InstrumentationLibrarySpans(this);
    }

    /// <summary>Field number for the "instrumentation_library" field.</summary>
    public const int InstrumentationLibraryFieldNumber = 1;
    private global::Opentelemetry.Proto.Common.V1.InstrumentationLibrary instrumentationLibrary_;
    /// <summary>
    /// The instrumentation library information for the spans in this message.
    /// Semantically when InstrumentationLibrary isn't set, it is equivalent with
    /// an empty instrumentation library name (unknown).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Opentelemetry.Proto.Common.V1.InstrumentationLibrary InstrumentationLibrary {
      get { return instrumentationLibrary_; }
      set {
        instrumentationLibrary_ = value;
      }
    }

    /// <summary>Field number for the "spans" field.</summary>
    public const int SpansFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Opentelemetry.Proto.Trace.V1.Span> _repeated_spans_codec
        = pb::FieldCodec.ForMessage(18, global::Opentelemetry.Proto.Trace.V1.Span.Parser);
    private readonly pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.Span> spans_ = new pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.Span>();
    /// <summary>
    /// A list of Spans that originate from an instrumentation library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.Span> Spans {
      get { return spans_; }
    }

    /// <summary>Field number for the "schema_url" field.</summary>
    public const int SchemaUrlFieldNumber = 3;
    private string schemaUrl_ = "";
    /// <summary>
    /// This schema_url applies to all spans and span events in the "spans" field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SchemaUrl {
      get { return schemaUrl_; }
      set {
        schemaUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as InstrumentationLibrarySpans);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(InstrumentationLibrarySpans other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(InstrumentationLibrary, other.InstrumentationLibrary)) return false;
      if(!spans_.Equals(other.spans_)) return false;
      if (SchemaUrl != other.SchemaUrl) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (instrumentationLibrary_ != null) hash ^= InstrumentationLibrary.GetHashCode();
      hash ^= spans_.GetHashCode();
      if (SchemaUrl.Length != 0) hash ^= SchemaUrl.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (instrumentationLibrary_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(InstrumentationLibrary);
      }
      spans_.WriteTo(output, _repeated_spans_codec);
      if (SchemaUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(SchemaUrl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (instrumentationLibrary_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(InstrumentationLibrary);
      }
      spans_.WriteTo(ref output, _repeated_spans_codec);
      if (SchemaUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(SchemaUrl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (instrumentationLibrary_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(InstrumentationLibrary);
      }
      size += spans_.CalculateSize(_repeated_spans_codec);
      if (SchemaUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SchemaUrl);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(InstrumentationLibrarySpans other) {
      if (other == null) {
        return;
      }
      if (other.instrumentationLibrary_ != null) {
        if (instrumentationLibrary_ == null) {
          InstrumentationLibrary = new global::Opentelemetry.Proto.Common.V1.InstrumentationLibrary();
        }
        InstrumentationLibrary.MergeFrom(other.InstrumentationLibrary);
      }
      spans_.Add(other.spans_);
      if (other.SchemaUrl.Length != 0) {
        SchemaUrl = other.SchemaUrl;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (instrumentationLibrary_ == null) {
              InstrumentationLibrary = new global::Opentelemetry.Proto.Common.V1.InstrumentationLibrary();
            }
            input.ReadMessage(InstrumentationLibrary);
            break;
          }
          case 18: {
            spans_.AddEntriesFrom(input, _repeated_spans_codec);
            break;
          }
          case 26: {
            SchemaUrl = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (instrumentationLibrary_ == null) {
              InstrumentationLibrary = new global::Opentelemetry.Proto.Common.V1.InstrumentationLibrary();
            }
            input.ReadMessage(InstrumentationLibrary);
            break;
          }
          case 18: {
            spans_.AddEntriesFrom(ref input, _repeated_spans_codec);
            break;
          }
          case 26: {
            SchemaUrl = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Span represents a single operation within a trace. Spans can be
  /// nested to form a trace tree. Spans may also be linked to other spans
  /// from the same or different trace and form graphs. Often, a trace
  /// contains a root span that describes the end-to-end latency, and one
  /// or more subspans for its sub-operations. A trace can also contain
  /// multiple root spans, or none at all. Spans do not need to be
  /// contiguous - there may be gaps or overlaps between spans in a trace.
  ///
  /// The next available field id is 17.
  /// </summary>
  public sealed partial class Span : pb::IMessage<Span>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Span> _parser = new pb::MessageParser<Span>(() => new Span());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Span> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Opentelemetry.Proto.Trace.V1.TraceReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Span() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Span(Span other) : this() {
      traceId_ = other.traceId_;
      spanId_ = other.spanId_;
      traceState_ = other.traceState_;
      parentSpanId_ = other.parentSpanId_;
      name_ = other.name_;
      kind_ = other.kind_;
      startTimeUnixNano_ = other.startTimeUnixNano_;
      endTimeUnixNano_ = other.endTimeUnixNano_;
      attributes_ = other.attributes_.Clone();
      droppedAttributesCount_ = other.droppedAttributesCount_;
      events_ = other.events_.Clone();
      droppedEventsCount_ = other.droppedEventsCount_;
      links_ = other.links_.Clone();
      droppedLinksCount_ = other.droppedLinksCount_;
      status_ = other.status_ != null ? other.status_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Span Clone() {
      return new Span(this);
    }

    /// <summary>Field number for the "trace_id" field.</summary>
    public const int TraceIdFieldNumber = 1;
    private pb::ByteString traceId_ = pb::ByteString.Empty;
    /// <summary>
    /// A unique identifier for a trace. All spans from the same trace share
    /// the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes
    /// is considered invalid.
    ///
    /// This field is semantically required. Receiver should generate new
    /// random trace_id if empty or invalid trace_id was received.
    ///
    /// This field is required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString TraceId {
      get { return traceId_; }
      set {
        traceId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "span_id" field.</summary>
    public const int SpanIdFieldNumber = 2;
    private pb::ByteString spanId_ = pb::ByteString.Empty;
    /// <summary>
    /// A unique identifier for a span within a trace, assigned when the span
    /// is created. The ID is an 8-byte array. An ID with all zeroes is considered
    /// invalid.
    ///
    /// This field is semantically required. Receiver should generate new
    /// random span_id if empty or invalid span_id was received.
    ///
    /// This field is required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString SpanId {
      get { return spanId_; }
      set {
        spanId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trace_state" field.</summary>
    public const int TraceStateFieldNumber = 3;
    private string traceState_ = "";
    /// <summary>
    /// trace_state conveys information about request position in multiple distributed tracing graphs.
    /// It is a trace_state in w3c-trace-context format: https://www.w3.org/TR/trace-context/#tracestate-header
    /// See also https://github.com/w3c/distributed-tracing for more details about this field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string TraceState {
      get { return traceState_; }
      set {
        traceState_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "parent_span_id" field.</summary>
    public const int ParentSpanIdFieldNumber = 4;
    private pb::ByteString parentSpanId_ = pb::ByteString.Empty;
    /// <summary>
    /// The `span_id` of this span's parent span. If this is a root span, then this
    /// field must be empty. The ID is an 8-byte array.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString ParentSpanId {
      get { return parentSpanId_; }
      set {
        parentSpanId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 5;
    private string name_ = "";
    /// <summary>
    /// A description of the span's operation.
    ///
    /// For example, the name can be a qualified method name or a file name
    /// and a line number where the operation is called. A best practice is to use
    /// the same display name at the same call point in an application.
    /// This makes it easier to correlate spans in different traces.
    ///
    /// This field is semantically required to be set to non-empty string.
    /// When null or empty string received - receiver may use string "name"
    /// as a replacement. There might be smarted algorithms implemented by
    /// receiver to fix the empty span name.
    ///
    /// This field is required.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "kind" field.</summary>
    public const int KindFieldNumber = 6;
    private global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind kind_ = global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind.Unspecified;
    /// <summary>
    /// Distinguishes between spans generated in a particular context. For example,
    /// two spans with the same name may be distinguished using `CLIENT` (caller)
    /// and `SERVER` (callee) to identify queueing latency associated with the span.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind Kind {
      get { return kind_; }
      set {
        kind_ = value;
      }
    }

    /// <summary>Field number for the "start_time_unix_nano" field.</summary>
    public const int StartTimeUnixNanoFieldNumber = 7;
    private ulong startTimeUnixNano_;
    /// <summary>
    /// start_time_unix_nano is the start time of the span. On the client side, this is the time
    /// kept by the local machine where the span execution starts. On the server side, this
    /// is the time when the server's application handler starts running.
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
    ///
    /// This field is semantically required and it is expected that end_time >= start_time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong StartTimeUnixNano {
      get { return startTimeUnixNano_; }
      set {
        startTimeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "end_time_unix_nano" field.</summary>
    public const int EndTimeUnixNanoFieldNumber = 8;
    private ulong endTimeUnixNano_;
    /// <summary>
    /// end_time_unix_nano is the end time of the span. On the client side, this is the time
    /// kept by the local machine where the span execution ends. On the server side, this
    /// is the time when the server application handler stops running.
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
    ///
    /// This field is semantically required and it is expected that end_time >= start_time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong EndTimeUnixNano {
      get { return endTimeUnixNano_; }
      set {
        endTimeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::Opentelemetry.Proto.Common.V1.KeyValue> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(74, global::Opentelemetry.Proto.Common.V1.KeyValue.Parser);
    private readonly pbc::RepeatedField<global::Opentelemetry.Proto.Common.V1.KeyValue> attributes_ = new pbc::RepeatedField<global::Opentelemetry.Proto.Common.V1.KeyValue>();
    /// <summary>
    /// attributes is a collection of key/value pairs. The value can be a string,
    /// an integer, a double or the Boolean values `true` or `false`. Note, global attributes
    /// like server name can be set using the resource API. Examples of attributes:
    ///
    ///     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
    ///     "/http/server_latency": 300
    ///     "abc.com/myattribute": true
    ///     "abc.com/score": 10.239
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Opentelemetry.Proto.Common.V1.KeyValue> Attributes {
      get { return attributes_; }
    }

    /// <summary>Field number for the "dropped_attributes_count" field.</summary>
    public const int DroppedAttributesCountFieldNumber = 10;
    private uint droppedAttributesCount_;
    /// <summary>
    /// dropped_attributes_count is the number of attributes that were discarded. Attributes
    /// can be discarded because their keys are too long or because there are too many
    /// attributes. If this value is 0, then no attributes were dropped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DroppedAttributesCount {
      get { return droppedAttributesCount_; }
      set {
        droppedAttributesCount_ = value;
      }
    }

    /// <summary>Field number for the "events" field.</summary>
    public const int EventsFieldNumber = 11;
    private static readonly pb::FieldCodec<global::Opentelemetry.Proto.Trace.V1.Span.Types.Event> _repeated_events_codec
        = pb::FieldCodec.ForMessage(90, global::Opentelemetry.Proto.Trace.V1.Span.Types.Event.Parser);
    private readonly pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.Span.Types.Event> events_ = new pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.Span.Types.Event>();
    /// <summary>
    /// events is a collection of Event items.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.Span.Types.Event> Events {
      get { return events_; }
    }

    /// <summary>Field number for the "dropped_events_count" field.</summary>
    public const int DroppedEventsCountFieldNumber = 12;
    private uint droppedEventsCount_;
    /// <summary>
    /// dropped_events_count is the number of dropped events. If the value is 0, then no
    /// events were dropped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DroppedEventsCount {
      get { return droppedEventsCount_; }
      set {
        droppedEventsCount_ = value;
      }
    }

    /// <summary>Field number for the "links" field.</summary>
    public const int LinksFieldNumber = 13;
    private static readonly pb::FieldCodec<global::Opentelemetry.Proto.Trace.V1.Span.Types.Link> _repeated_links_codec
        = pb::FieldCodec.ForMessage(106, global::Opentelemetry.Proto.Trace.V1.Span.Types.Link.Parser);
    private readonly pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.Span.Types.Link> links_ = new pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.Span.Types.Link>();
    /// <summary>
    /// links is a collection of Links, which are references from this span to a span
    /// in the same or different trace.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Opentelemetry.Proto.Trace.V1.Span.Types.Link> Links {
      get { return links_; }
    }

    /// <summary>Field number for the "dropped_links_count" field.</summary>
    public const int DroppedLinksCountFieldNumber = 14;
    private uint droppedLinksCount_;
    /// <summary>
    /// dropped_links_count is the number of dropped links after the maximum size was
    /// enforced. If this value is 0, then no links were dropped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint DroppedLinksCount {
      get { return droppedLinksCount_; }
      set {
        droppedLinksCount_ = value;
      }
    }

    /// <summary>Field number for the "status" field.</summary>
    public const int StatusFieldNumber = 15;
    private global::Opentelemetry.Proto.Trace.V1.Status status_;
    /// <summary>
    /// An optional final status for this span. Semantically when Status isn't set, it means
    /// span's status code is unset, i.e. assume STATUS_CODE_UNSET (code = 0).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Opentelemetry.Proto.Trace.V1.Status Status {
      get { return status_; }
      set {
        status_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Span);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Span other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TraceId != other.TraceId) return false;
      if (SpanId != other.SpanId) return false;
      if (TraceState != other.TraceState) return false;
      if (ParentSpanId != other.ParentSpanId) return false;
      if (Name != other.Name) return false;
      if (Kind != other.Kind) return false;
      if (StartTimeUnixNano != other.StartTimeUnixNano) return false;
      if (EndTimeUnixNano != other.EndTimeUnixNano) return false;
      if(!attributes_.Equals(other.attributes_)) return false;
      if (DroppedAttributesCount != other.DroppedAttributesCount) return false;
      if(!events_.Equals(other.events_)) return false;
      if (DroppedEventsCount != other.DroppedEventsCount) return false;
      if(!links_.Equals(other.links_)) return false;
      if (DroppedLinksCount != other.DroppedLinksCount) return false;
      if (!object.Equals(Status, other.Status)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (TraceId.Length != 0) hash ^= TraceId.GetHashCode();
      if (SpanId.Length != 0) hash ^= SpanId.GetHashCode();
      if (TraceState.Length != 0) hash ^= TraceState.GetHashCode();
      if (ParentSpanId.Length != 0) hash ^= ParentSpanId.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Kind != global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind.Unspecified) hash ^= Kind.GetHashCode();
      if (StartTimeUnixNano != 0UL) hash ^= StartTimeUnixNano.GetHashCode();
      if (EndTimeUnixNano != 0UL) hash ^= EndTimeUnixNano.GetHashCode();
      hash ^= attributes_.GetHashCode();
      if (DroppedAttributesCount != 0) hash ^= DroppedAttributesCount.GetHashCode();
      hash ^= events_.GetHashCode();
      if (DroppedEventsCount != 0) hash ^= DroppedEventsCount.GetHashCode();
      hash ^= links_.GetHashCode();
      if (DroppedLinksCount != 0) hash ^= DroppedLinksCount.GetHashCode();
      if (status_ != null) hash ^= Status.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TraceId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(TraceId);
      }
      if (SpanId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(SpanId);
      }
      if (TraceState.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(TraceState);
      }
      if (ParentSpanId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(ParentSpanId);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Name);
      }
      if (Kind != global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Kind);
      }
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(57);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (EndTimeUnixNano != 0UL) {
        output.WriteRawTag(65);
        output.WriteFixed64(EndTimeUnixNano);
      }
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (DroppedAttributesCount != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(DroppedAttributesCount);
      }
      events_.WriteTo(output, _repeated_events_codec);
      if (DroppedEventsCount != 0) {
        output.WriteRawTag(96);
        output.WriteUInt32(DroppedEventsCount);
      }
      links_.WriteTo(output, _repeated_links_codec);
      if (DroppedLinksCount != 0) {
        output.WriteRawTag(112);
        output.WriteUInt32(DroppedLinksCount);
      }
      if (status_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TraceId.Length != 0) {
        output.WriteRawTag(10);
        output.WriteBytes(TraceId);
      }
      if (SpanId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteBytes(SpanId);
      }
      if (TraceState.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(TraceState);
      }
      if (ParentSpanId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(ParentSpanId);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Name);
      }
      if (Kind != global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind.Unspecified) {
        output.WriteRawTag(48);
        output.WriteEnum((int) Kind);
      }
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(57);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (EndTimeUnixNano != 0UL) {
        output.WriteRawTag(65);
        output.WriteFixed64(EndTimeUnixNano);
      }
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (DroppedAttributesCount != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(DroppedAttributesCount);
      }
      events_.WriteTo(ref output, _repeated_events_codec);
      if (DroppedEventsCount != 0) {
        output.WriteRawTag(96);
        output.WriteUInt32(DroppedEventsCount);
      }
      links_.WriteTo(ref output, _repeated_links_codec);
      if (DroppedLinksCount != 0) {
        output.WriteRawTag(112);
        output.WriteUInt32(DroppedLinksCount);
      }
      if (status_ != null) {
        output.WriteRawTag(122);
        output.WriteMessage(Status);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (TraceId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(TraceId);
      }
      if (SpanId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SpanId);
      }
      if (TraceState.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(TraceState);
      }
      if (ParentSpanId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(ParentSpanId);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Kind != global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Kind);
      }
      if (StartTimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (EndTimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (DroppedAttributesCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DroppedAttributesCount);
      }
      size += events_.CalculateSize(_repeated_events_codec);
      if (DroppedEventsCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DroppedEventsCount);
      }
      size += links_.CalculateSize(_repeated_links_codec);
      if (DroppedLinksCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DroppedLinksCount);
      }
      if (status_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Status);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Span other) {
      if (other == null) {
        return;
      }
      if (other.TraceId.Length != 0) {
        TraceId = other.TraceId;
      }
      if (other.SpanId.Length != 0) {
        SpanId = other.SpanId;
      }
      if (other.TraceState.Length != 0) {
        TraceState = other.TraceState;
      }
      if (other.ParentSpanId.Length != 0) {
        ParentSpanId = other.ParentSpanId;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Kind != global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind.Unspecified) {
        Kind = other.Kind;
      }
      if (other.StartTimeUnixNano != 0UL) {
        StartTimeUnixNano = other.StartTimeUnixNano;
      }
      if (other.EndTimeUnixNano != 0UL) {
        EndTimeUnixNano = other.EndTimeUnixNano;
      }
      attributes_.Add(other.attributes_);
      if (other.DroppedAttributesCount != 0) {
        DroppedAttributesCount = other.DroppedAttributesCount;
      }
      events_.Add(other.events_);
      if (other.DroppedEventsCount != 0) {
        DroppedEventsCount = other.DroppedEventsCount;
      }
      links_.Add(other.links_);
      if (other.DroppedLinksCount != 0) {
        DroppedLinksCount = other.DroppedLinksCount;
      }
      if (other.status_ != null) {
        if (status_ == null) {
          Status = new global::Opentelemetry.Proto.Trace.V1.Status();
        }
        Status.MergeFrom(other.Status);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            TraceId = input.ReadBytes();
            break;
          }
          case 18: {
            SpanId = input.ReadBytes();
            break;
          }
          case 26: {
            TraceState = input.ReadString();
            break;
          }
          case 34: {
            ParentSpanId = input.ReadBytes();
            break;
          }
          case 42: {
            Name = input.ReadString();
            break;
          }
          case 48: {
            Kind = (global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind) input.ReadEnum();
            break;
          }
          case 57: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 65: {
            EndTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 74: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
          case 80: {
            DroppedAttributesCount = input.ReadUInt32();
            break;
          }
          case 90: {
            events_.AddEntriesFrom(input, _repeated_events_codec);
            break;
          }
          case 96: {
            DroppedEventsCount = input.ReadUInt32();
            break;
          }
          case 106: {
            links_.AddEntriesFrom(input, _repeated_links_codec);
            break;
          }
          case 112: {
            DroppedLinksCount = input.ReadUInt32();
            break;
          }
          case 122: {
            if (status_ == null) {
              Status = new global::Opentelemetry.Proto.Trace.V1.Status();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            TraceId = input.ReadBytes();
            break;
          }
          case 18: {
            SpanId = input.ReadBytes();
            break;
          }
          case 26: {
            TraceState = input.ReadString();
            break;
          }
          case 34: {
            ParentSpanId = input.ReadBytes();
            break;
          }
          case 42: {
            Name = input.ReadString();
            break;
          }
          case 48: {
            Kind = (global::Opentelemetry.Proto.Trace.V1.Span.Types.SpanKind) input.ReadEnum();
            break;
          }
          case 57: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 65: {
            EndTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 74: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
          case 80: {
            DroppedAttributesCount = input.ReadUInt32();
            break;
          }
          case 90: {
            events_.AddEntriesFrom(ref input, _repeated_events_codec);
            break;
          }
          case 96: {
            DroppedEventsCount = input.ReadUInt32();
            break;
          }
          case 106: {
            links_.AddEntriesFrom(ref input, _repeated_links_codec);
            break;
          }
          case 112: {
            DroppedLinksCount = input.ReadUInt32();
            break;
          }
          case 122: {
            if (status_ == null) {
              Status = new global::Opentelemetry.Proto.Trace.V1.Status();
            }
            input.ReadMessage(Status);
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Span message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// SpanKind is the type of span. Can be used to specify additional relationships between spans
      /// in addition to a parent/child relationship.
      /// </summary>
      public enum SpanKind {
        /// <summary>
        /// Unspecified. Do NOT use as default.
        /// Implementations MAY assume SpanKind to be INTERNAL when receiving UNSPECIFIED.
        /// </summary>
        [pbr::OriginalName("SPAN_KIND_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// Indicates that the span represents an internal operation within an application,
        /// as opposed to an operation happening at the boundaries. Default value.
        /// </summary>
        [pbr::OriginalName("SPAN_KIND_INTERNAL")] Internal = 1,
        /// <summary>
        /// Indicates that the span covers server-side handling of an RPC or other
        /// remote network request.
        /// </summary>
        [pbr::OriginalName("SPAN_KIND_SERVER")] Server = 2,
        /// <summary>
        /// Indicates that the span describes a request to some remote service.
        /// </summary>
        [pbr::OriginalName("SPAN_KIND_CLIENT")] Client = 3,
        /// <summary>
        /// Indicates that the span describes a producer sending a message to a broker.
        /// Unlike CLIENT and SERVER, there is often no direct critical path latency relationship
        /// between producer and consumer spans. A PRODUCER span ends when the message was accepted
        /// by the broker while the logical processing of the message might span a much longer time.
        /// </summary>
        [pbr::OriginalName("SPAN_KIND_PRODUCER")] Producer = 4,
        /// <summary>
        /// Indicates that the span describes consumer receiving a message from a broker.
        /// Like the PRODUCER kind, there is often no direct critical path latency relationship
        /// between producer and consumer spans.
        /// </summary>
        [pbr::OriginalName("SPAN_KIND_CONSUMER")] Consumer = 5,
      }

      /// <summary>
      /// Event is a time-stamped annotation of the span, consisting of user-supplied
      /// text description and key-value pairs.
      /// </summary>
      public sealed partial class Event : pb::IMessage<Event>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Event> _parser = new pb::MessageParser<Event>(() => new Event());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Event> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Opentelemetry.Proto.Trace.V1.Span.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Event() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Event(Event other) : this() {
          timeUnixNano_ = other.timeUnixNano_;
          name_ = other.name_;
          attributes_ = other.attributes_.Clone();
          droppedAttributesCount_ = other.droppedAttributesCount_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Event Clone() {
          return new Event(this);
        }

        /// <summary>Field number for the "time_unix_nano" field.</summary>
        public const int TimeUnixNanoFieldNumber = 1;
        private ulong timeUnixNano_;
        /// <summary>
        /// time_unix_nano is the time the event occurred.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public ulong TimeUnixNano {
          get { return timeUnixNano_; }
          set {
            timeUnixNano_ = value;
          }
        }

        /// <summary>Field number for the "name" field.</summary>
        public const int NameFieldNumber = 2;
        private string name_ = "";
        /// <summary>
        /// name of the event.
        /// This field is semantically required to be set to non-empty string.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string Name {
          get { return name_; }
          set {
            name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "attributes" field.</summary>
        public const int AttributesFieldNumber = 3;
        private static readonly pb::FieldCodec<global::Opentelemetry.Proto.Common.V1.KeyValue> _repeated_attributes_codec
            = pb::FieldCodec.ForMessage(26, global::Opentelemetry.Proto.Common.V1.KeyValue.Parser);
        private readonly pbc::RepeatedField<global::Opentelemetry.Proto.Common.V1.KeyValue> attributes_ = new pbc::RepeatedField<global::Opentelemetry.Proto.Common.V1.KeyValue>();
        /// <summary>
        /// attributes is a collection of attribute key/value pairs on the event.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Opentelemetry.Proto.Common.V1.KeyValue> Attributes {
          get { return attributes_; }
        }

        /// <summary>Field number for the "dropped_attributes_count" field.</summary>
        public const int DroppedAttributesCountFieldNumber = 4;
        private uint droppedAttributesCount_;
        /// <summary>
        /// dropped_attributes_count is the number of dropped attributes. If the value is 0,
        /// then no attributes were dropped.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint DroppedAttributesCount {
          get { return droppedAttributesCount_; }
          set {
            droppedAttributesCount_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Event);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Event other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (TimeUnixNano != other.TimeUnixNano) return false;
          if (Name != other.Name) return false;
          if(!attributes_.Equals(other.attributes_)) return false;
          if (DroppedAttributesCount != other.DroppedAttributesCount) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (TimeUnixNano != 0UL) hash ^= TimeUnixNano.GetHashCode();
          if (Name.Length != 0) hash ^= Name.GetHashCode();
          hash ^= attributes_.GetHashCode();
          if (DroppedAttributesCount != 0) hash ^= DroppedAttributesCount.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (TimeUnixNano != 0UL) {
            output.WriteRawTag(9);
            output.WriteFixed64(TimeUnixNano);
          }
          if (Name.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Name);
          }
          attributes_.WriteTo(output, _repeated_attributes_codec);
          if (DroppedAttributesCount != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(DroppedAttributesCount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (TimeUnixNano != 0UL) {
            output.WriteRawTag(9);
            output.WriteFixed64(TimeUnixNano);
          }
          if (Name.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Name);
          }
          attributes_.WriteTo(ref output, _repeated_attributes_codec);
          if (DroppedAttributesCount != 0) {
            output.WriteRawTag(32);
            output.WriteUInt32(DroppedAttributesCount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (TimeUnixNano != 0UL) {
            size += 1 + 8;
          }
          if (Name.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
          }
          size += attributes_.CalculateSize(_repeated_attributes_codec);
          if (DroppedAttributesCount != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DroppedAttributesCount);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Event other) {
          if (other == null) {
            return;
          }
          if (other.TimeUnixNano != 0UL) {
            TimeUnixNano = other.TimeUnixNano;
          }
          if (other.Name.Length != 0) {
            Name = other.Name;
          }
          attributes_.Add(other.attributes_);
          if (other.DroppedAttributesCount != 0) {
            DroppedAttributesCount = other.DroppedAttributesCount;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 9: {
                TimeUnixNano = input.ReadFixed64();
                break;
              }
              case 18: {
                Name = input.ReadString();
                break;
              }
              case 26: {
                attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
                break;
              }
              case 32: {
                DroppedAttributesCount = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 9: {
                TimeUnixNano = input.ReadFixed64();
                break;
              }
              case 18: {
                Name = input.ReadString();
                break;
              }
              case 26: {
                attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
                break;
              }
              case 32: {
                DroppedAttributesCount = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

      }

      /// <summary>
      /// A pointer from the current span to another span in the same trace or in a
      /// different trace. For example, this can be used in batching operations,
      /// where a single batch handler processes multiple requests from different
      /// traces or when the handler receives a request from a different project.
      /// </summary>
      public sealed partial class Link : pb::IMessage<Link>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Link> _parser = new pb::MessageParser<Link>(() => new Link());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Link> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Opentelemetry.Proto.Trace.V1.Span.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Link() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Link(Link other) : this() {
          traceId_ = other.traceId_;
          spanId_ = other.spanId_;
          traceState_ = other.traceState_;
          attributes_ = other.attributes_.Clone();
          droppedAttributesCount_ = other.droppedAttributesCount_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Link Clone() {
          return new Link(this);
        }

        /// <summary>Field number for the "trace_id" field.</summary>
        public const int TraceIdFieldNumber = 1;
        private pb::ByteString traceId_ = pb::ByteString.Empty;
        /// <summary>
        /// A unique identifier of a trace that this linked span is part of. The ID is a
        /// 16-byte array.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString TraceId {
          get { return traceId_; }
          set {
            traceId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "span_id" field.</summary>
        public const int SpanIdFieldNumber = 2;
        private pb::ByteString spanId_ = pb::ByteString.Empty;
        /// <summary>
        /// A unique identifier for the linked span. The ID is an 8-byte array.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pb::ByteString SpanId {
          get { return spanId_; }
          set {
            spanId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "trace_state" field.</summary>
        public const int TraceStateFieldNumber = 3;
        private string traceState_ = "";
        /// <summary>
        /// The trace_state associated with the link.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public string TraceState {
          get { return traceState_; }
          set {
            traceState_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "attributes" field.</summary>
        public const int AttributesFieldNumber = 4;
        private static readonly pb::FieldCodec<global::Opentelemetry.Proto.Common.V1.KeyValue> _repeated_attributes_codec
            = pb::FieldCodec.ForMessage(34, global::Opentelemetry.Proto.Common.V1.KeyValue.Parser);
        private readonly pbc::RepeatedField<global::Opentelemetry.Proto.Common.V1.KeyValue> attributes_ = new pbc::RepeatedField<global::Opentelemetry.Proto.Common.V1.KeyValue>();
        /// <summary>
        /// attributes is a collection of attribute key/value pairs on the link.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::Opentelemetry.Proto.Common.V1.KeyValue> Attributes {
          get { return attributes_; }
        }

        /// <summary>Field number for the "dropped_attributes_count" field.</summary>
        public const int DroppedAttributesCountFieldNumber = 5;
        private uint droppedAttributesCount_;
        /// <summary>
        /// dropped_attributes_count is the number of dropped attributes. If the value is 0,
        /// then no attributes were dropped.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public uint DroppedAttributesCount {
          get { return droppedAttributesCount_; }
          set {
            droppedAttributesCount_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Link);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Link other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (TraceId != other.TraceId) return false;
          if (SpanId != other.SpanId) return false;
          if (TraceState != other.TraceState) return false;
          if(!attributes_.Equals(other.attributes_)) return false;
          if (DroppedAttributesCount != other.DroppedAttributesCount) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (TraceId.Length != 0) hash ^= TraceId.GetHashCode();
          if (SpanId.Length != 0) hash ^= SpanId.GetHashCode();
          if (TraceState.Length != 0) hash ^= TraceState.GetHashCode();
          hash ^= attributes_.GetHashCode();
          if (DroppedAttributesCount != 0) hash ^= DroppedAttributesCount.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (TraceId.Length != 0) {
            output.WriteRawTag(10);
            output.WriteBytes(TraceId);
          }
          if (SpanId.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(SpanId);
          }
          if (TraceState.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(TraceState);
          }
          attributes_.WriteTo(output, _repeated_attributes_codec);
          if (DroppedAttributesCount != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(DroppedAttributesCount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (TraceId.Length != 0) {
            output.WriteRawTag(10);
            output.WriteBytes(TraceId);
          }
          if (SpanId.Length != 0) {
            output.WriteRawTag(18);
            output.WriteBytes(SpanId);
          }
          if (TraceState.Length != 0) {
            output.WriteRawTag(26);
            output.WriteString(TraceState);
          }
          attributes_.WriteTo(ref output, _repeated_attributes_codec);
          if (DroppedAttributesCount != 0) {
            output.WriteRawTag(40);
            output.WriteUInt32(DroppedAttributesCount);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (TraceId.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(TraceId);
          }
          if (SpanId.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeBytesSize(SpanId);
          }
          if (TraceState.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(TraceState);
          }
          size += attributes_.CalculateSize(_repeated_attributes_codec);
          if (DroppedAttributesCount != 0) {
            size += 1 + pb::CodedOutputStream.ComputeUInt32Size(DroppedAttributesCount);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Link other) {
          if (other == null) {
            return;
          }
          if (other.TraceId.Length != 0) {
            TraceId = other.TraceId;
          }
          if (other.SpanId.Length != 0) {
            SpanId = other.SpanId;
          }
          if (other.TraceState.Length != 0) {
            TraceState = other.TraceState;
          }
          attributes_.Add(other.attributes_);
          if (other.DroppedAttributesCount != 0) {
            DroppedAttributesCount = other.DroppedAttributesCount;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 10: {
                TraceId = input.ReadBytes();
                break;
              }
              case 18: {
                SpanId = input.ReadBytes();
                break;
              }
              case 26: {
                TraceState = input.ReadString();
                break;
              }
              case 34: {
                attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
                break;
              }
              case 40: {
                DroppedAttributesCount = input.ReadUInt32();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 10: {
                TraceId = input.ReadBytes();
                break;
              }
              case 18: {
                SpanId = input.ReadBytes();
                break;
              }
              case 26: {
                TraceState = input.ReadString();
                break;
              }
              case 34: {
                attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
                break;
              }
              case 40: {
                DroppedAttributesCount = input.ReadUInt32();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// The Status type defines a logical error model that is suitable for different
  /// programming environments, including REST APIs and RPC APIs.
  /// </summary>
  public sealed partial class Status : pb::IMessage<Status>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Status> _parser = new pb::MessageParser<Status>(() => new Status());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Status> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Opentelemetry.Proto.Trace.V1.TraceReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Status() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Status(Status other) : this() {
      deprecatedCode_ = other.deprecatedCode_;
      message_ = other.message_;
      code_ = other.code_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Status Clone() {
      return new Status(this);
    }

    /// <summary>Field number for the "deprecated_code" field.</summary>
    public const int DeprecatedCodeFieldNumber = 1;
    private global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode deprecatedCode_ = global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode.Ok;
    /// <summary>
    /// The deprecated status code. This is an optional field.
    ///
    /// This field is deprecated and is replaced by the `code` field below. See backward
    /// compatibility notes below. According to our stability guarantees this field
    /// will be removed in 12 months, on Oct 22, 2021. All usage of old senders and
    /// receivers that do not understand the `code` field MUST be phased out by then.
    /// </summary>
    [global::System.ObsoleteAttribute]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode DeprecatedCode {
      get { return deprecatedCode_; }
      set {
        deprecatedCode_ = value;
      }
    }

    /// <summary>Field number for the "message" field.</summary>
    public const int MessageFieldNumber = 2;
    private string message_ = "";
    /// <summary>
    /// A developer-facing human readable error message.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Message {
      get { return message_; }
      set {
        message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "code" field.</summary>
    public const int CodeFieldNumber = 3;
    private global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode code_ = global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode.Unset;
    /// <summary>
    /// The status code.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode Code {
      get { return code_; }
      set {
        code_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Status);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Status other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DeprecatedCode != other.DeprecatedCode) return false;
      if (Message != other.Message) return false;
      if (Code != other.Code) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DeprecatedCode != global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode.Ok) hash ^= DeprecatedCode.GetHashCode();
      if (Message.Length != 0) hash ^= Message.GetHashCode();
      if (Code != global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode.Unset) hash ^= Code.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (DeprecatedCode != global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode.Ok) {
        output.WriteRawTag(8);
        output.WriteEnum((int) DeprecatedCode);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (Code != global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode.Unset) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Code);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (DeprecatedCode != global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode.Ok) {
        output.WriteRawTag(8);
        output.WriteEnum((int) DeprecatedCode);
      }
      if (Message.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Message);
      }
      if (Code != global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode.Unset) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Code);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DeprecatedCode != global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode.Ok) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DeprecatedCode);
      }
      if (Message.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
      }
      if (Code != global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode.Unset) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Code);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Status other) {
      if (other == null) {
        return;
      }
      if (other.DeprecatedCode != global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode.Ok) {
        DeprecatedCode = other.DeprecatedCode;
      }
      if (other.Message.Length != 0) {
        Message = other.Message;
      }
      if (other.Code != global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode.Unset) {
        Code = other.Code;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            DeprecatedCode = (global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode) input.ReadEnum();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
          case 24: {
            Code = (global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            DeprecatedCode = (global::Opentelemetry.Proto.Trace.V1.Status.Types.DeprecatedStatusCode) input.ReadEnum();
            break;
          }
          case 18: {
            Message = input.ReadString();
            break;
          }
          case 24: {
            Code = (global::Opentelemetry.Proto.Trace.V1.Status.Types.StatusCode) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the Status message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum DeprecatedStatusCode {
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_OK")] Ok = 0,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_CANCELLED")] Cancelled = 1,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_UNKNOWN_ERROR")] UnknownError = 2,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_INVALID_ARGUMENT")] InvalidArgument = 3,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_DEADLINE_EXCEEDED")] DeadlineExceeded = 4,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_NOT_FOUND")] NotFound = 5,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_ALREADY_EXISTS")] AlreadyExists = 6,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_PERMISSION_DENIED")] PermissionDenied = 7,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_RESOURCE_EXHAUSTED")] ResourceExhausted = 8,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_FAILED_PRECONDITION")] FailedPrecondition = 9,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_ABORTED")] Aborted = 10,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_OUT_OF_RANGE")] OutOfRange = 11,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_UNIMPLEMENTED")] Unimplemented = 12,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_INTERNAL_ERROR")] InternalError = 13,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_UNAVAILABLE")] Unavailable = 14,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_DATA_LOSS")] DataLoss = 15,
        [pbr::OriginalName("DEPRECATED_STATUS_CODE_UNAUTHENTICATED")] Unauthenticated = 16,
      }

      /// <summary>
      /// For the semantics of status codes see
      /// https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/api.md#set-status
      /// </summary>
      public enum StatusCode {
        /// <summary>
        /// The default status.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_UNSET")] Unset = 0,
        /// <summary>
        /// The Span has been validated by an Application developers or Operator to have
        /// completed successfully.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_OK")] Ok = 1,
        /// <summary>
        /// The Span contains an error.
        /// </summary>
        [pbr::OriginalName("STATUS_CODE_ERROR")] Error = 2,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
